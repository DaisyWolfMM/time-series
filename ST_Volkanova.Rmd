---
title: "Stat_VR"
author: "Волканова Маргарита"
date: '28 февраля 2019 г '
output:
  html_document:
    toc: true 
    toc_depth: 3
    toc_float: true
    number_sections: true

---
```{r}
library(Rssa)
library(stats)
```

#Статистический анализ временных рядов
##Временной ряд


Общее задание: Провести анализ ряда - выделить тренд, исследовать частотные характеристики ряда и остатка после выделения тренда. При этом использовать фильтры, АЧХ и периодограмму

Любая метрика, которая измеряется через регулярные интервалы времени, составляет временной ряд. Пример: данные о погоде, цены на акции, отраслевые прогнозы и т. Д. Являются одними из наиболее распространенных.\
Будем рассматривать временной ряд, представляющий собой среднемесячные значения уровня безработицы: 18 лет и старше. Период времени с 2000-01-01 по 2019-01-01.Всего 229 моментов времени. 
```{r}
series<-read.csv("D:/Dokumy/Desktop/Golyandina/UR_V_18s.csv",sep=",")
names(series)[2]<-"level"
```
##Ts в R, как задается временной ряд и временная шкала. 
data - вектор или матрица наблюдаемых значений временного ряда;\
start-end - время первого и последнего наблюдения. Либо одно число, либо вектор из двух целых чисел c (1959, 2);\
frequency - количество наблюдений за единицу времени, период;\
deltat - частота;\
class - класс, который будет передан результату;\
names - символьный вектор имен для ряда в нескольких рядах: по умолчанию это имена столбцов data;\
bandwith - $\frac{1}{N}$;\
```{r}
series_ts<-ts(series$level,frequency = 12,start=c(2000,1),end=c(2018,12))
series_ts

```


#Автокорреляции
Временной ряд: $Y^T=Y_1, \ldots,Y_T$;\
Более формальным способом проверки наличия временной взаимосвязи между значениями анализируемой переменной является расчет автокорреляции
\[r_\tau=r_{y_ty_{t-\tau}}=\frac{\frac{1}{T-\tau}\sum_{t=\tau+1}^{T}(y_t-\overline{y})(y_{t-\tau}-\overline{y})}{\sqrt{\frac{1}{T-\tau}\sum_{t=\tau+1}^{T}(y_t-\overline{y})^2}\sqrt{\frac{1}{T-\tau}\sum_{t=\tau+1}^{T}(y_{t-\tau}-\overline{y})^2}},\;  \overline{y}=\frac{1}{T}\sum_{t=1}^{T}y_t\]
$r_\tau \in [-1,1],$ $\tau$ - лаг автокорреляции.
При оценке этой функции последовательно происходит рассчет коэффициента корреляции Пирсона между значениями того же временного ряда, но каждый раз взятых со сдвигом по времени на определенную величину k (лаг)(величина лага k=200 соответствует месяцам).\
Из этого рисунка хорошо видна тесная временная взаимосвязь между значениями представляющий собой среднемесячные значения уровня безработицы. \
Lag - это насколько сдвигаем ряд и смотри корреляцию между исходным рядом и его сдвигом.(Lag=0 - сам с собой, поэтому еденица; Lag=1 - соседи; Lag=2  - сдвиг на 2 и т.д.). Чем больше Lag тем меньше отрезок ряда по которому оцениваем корреляцию. При сдвиге ряд просто укорачивается, он не дополняется нулями (разница: так как число слагаемых будет разное, то и делить будем на разные  - число ненулеых слагаемых. Чем короче ненулевой отрезок, тем меньше будет число на которое делим.)


###Главный вопрос: Является ли процесс белым шумом?
(Авторкорреляцию используем для проверки "как хорошо" выделили сигнал.Смотрим на остаток, если он белый шум - хорошо)\

Для каждого Lag проверяется гипотеза \[H_0: r_\tau =0,\]альтернативная гипотеза
\[H_1: r_\tau \not=0.\]
Пунктирные линии синего цвета соответствуют 95%-ной доверительной области.\
Если значение внутри доверительной области - не отвергается гипотеза.\

```{r}
acf(series_ts, lag.max = 200,main="Автокорреляции")
    
```

Если исходная функция строго периодическая, то на графике автокорреляционной функции тоже будет строго периодическая функция. Но судить о периодичности исходной функции, а следовательно, и о её частотных характеристиках лучше смотреть по периодограмме. 


#Периодограмма
Пусть $X_N = (x_1,\ldots,x_N)$ - ряд длины N.\
\[x_n=c_0+\sum^{[N/2]}_{k=1}(c_k \cos(2\pi nk/N)+s_k\sin(2\pi nk/N)),\]
Разложение Фурье ряда $X_N$. Здесь $0<=n<N$ и $s_{N/2}=0$ для четного $N$.\
Периодограммой ряда $X_N$ называется функция $П^{N}_{x}$, которая задается формулой
\begin{equation*}
П^{N}_{x}= \frac{N}{2}
 \begin{cases}
   2c^2_0 &\text{для $k=0$}\\
   c^2_k+s^2_k &\text{для $0<k<N/2$}\\   2c^2_{N/2} &\text{для $k=N/2$}
 \end{cases}
\end{equation*}
Норма ряда имеет вид 
\[||X_N||^2=\sum^{[N/2]}_{k=0}П^N_x(k/N).\]
Другими словами значение периодограммы в точке k/N описывает вклад гармонической компоненты с частатой $\omega = k/N$. По периодограмме можно понять, какие частоты есть в разложении Фурье данного ряда.\
С помощью периодограммы  видим из каких частот состоит ряд. Для этого разложим в ряд Фурье (по ортогональному базису состоящему из sin и cos). Смотрим на соответствующие коэффициенты $C_k$ и $S_k$. \

Добавляя фазу разложение по базису можно записать в виде косинусов ($A_0=C_0)$):
\[x_n=A_0+ \sum^{[N/2]}_{k=1} A_k \cos (2\pi n \frac{k}{N} +\phi_k)\]
где $A_k$ - амплитуда, $\phi_k$ - фаза.
По $A^2_k= C_k^2+ S_k^2$ смотрим вклад частоты в ряд. Частота $\omega = \frac{1}{T}$, то есть по периодограмме видим из каких частот состоит ряд. Минимальные период $T=1$, тогда $w=\frac{1}{2}$.\
По сути происходит разложение ряда в сумму косинусов и мы смотрим с какими периодами косинусы входят в сумму (не все косинусы могут входить в сумму). 




##Общая периодограмма 
Видно, что колебания с частотой 1/12 вносят вклад. То есть ряд содержит периодическую компоненту с периодами 12.Аналогично с периодическими компонентами 6 и 2.
```{r}
#spec.pgram(series_ts,log="no",detrend = TRUE,taper=0,xaxt='n',ann="False")
#,detrend = TRUE,demean=TRUE
#detrend = false вычитание линейного тренда 
#lines(x=rep(1/144,70),y=c(1:70),type="l",col = "red")


spec.pgram(series_ts,ylim=c(0,1),log="no",detrend=FALSE,xaxt='n',fast =FALSE,main="Общая педиограмма",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))

spec.pgram(series_ts,ylim=c(0,1),log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Общая педиограмма без линейного тренда",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))
#fast -если TRUE , дополняйте серию до длины, раскладываемаю в произведение небольших сомножителей (в идеале - степень двойки), чтобы быстрее считалось FFT.
#demean -Если TRUE , вычтите среднее значение ряда.
#detrend - Если TRUE , удалите линейный тренд из ряда. Это также удалит среднее. - лучше видим переодичность 
```


#Красный и белый шум
##Белый шум
Белый шум — стационарный шум, спектральные составляющие которого равномерно распределены по всему диапазону задействованных частот.\
Для сглаживания  (выделения спектрально плотности) добавим spans  - вектор нечетных целых чисел, дающий ширину модифицированных сглаживателей Даниэля, которые будут использоваться для сглаживания периодограммы.Окно Даниэля означает простое (с равными весами) сглаживание скользящим средним значений периодограммы. \
Периодограмма белого шума (красная линия - оценка спектральной плотности сглаживанием периодограммы):
```{r}
w_noise <- rnorm(1000)

spec.pgram(w_noise, log = "no",fast = FALSE, pad = FALSE,taper = 0,main="Сглаженная педиограмма белого шума")
#Предполагаем, что спектральная плотность медленно меняется от частоты к частоте поэтому беру spans = c(50,50)
spec.pgram(w_noise,spans = c(50,50),detrend = FALSE, log = "no",fast = FALSE, pad = FALSE,taper = 0,xaxt='n', col="red", add=TRUE,xaxt='n')

```

Убедимся по Автокорреляции, что это белый шум:
```{r}
acf(w_noise)
```


##Красный шум
У красного шума побольше низких частот и поменьше высоких. Другими словами низкие частоты искажает больше, чем белый, что означает, что при красном шуме Тренд выделить сложнее.\
$\xi_n = a \xi_{n-1} + \epsilon, 0<a<1$
Периодограмма красный шум (Броуновский шум):
```{r}

bm <- w_noise[1]
for(i in 1:(1000 - 1)){
 bm[i + 1] <- 0.3*bm[i] + sqrt(1 - 0.1) * w_noise[i+1]
}
bm <- ts(bm)


spec.pgram(bm, log = "no",fast = FALSE, pad = FALSE,taper = 0,main="Сглаженная педиограмма красного шума")

spec.pgram(bm,spans = c(50,50),detrend = FALSE, log = "no",fast = FALSE, pad = FALSE,taper = 0,xaxt='n', col="red", add=TRUE,xaxt='n')
```


Знаем, что у шума 
\[\frac{1}{N}||X_N||^2=\sum^N_{k=0}I^N_x(\frac{k}{N})  \rightarrow const, \text{ при } N\rightarrow\infty\]
где $I^N_x(\frac{k}{N})=П^N_x(\frac{k}{N})/N$. Среднее значение с увеличением N уменьшается, так как левая часть не изсеняется, а в правой увеличивается количество слагаемых с ростом N.




#Выделение тренда и подавление шума.



##Фильтрация

Фильтрация – способ подавления шума, выделения тренда (тенденцию изменения показателей временного ряда).\
Линейный фильтр – линейная комбинация элементов исходного ряда с некоторыми коэффициентами. 
\[y_j=\sum^{\infty}_{i=-\infty}h_ix_{j-k}, \text{где $h_i$ параметры фильтра.}\]
$\{h_i\}$ - импульсная характеристика ($\ldots,h_{-1}, h_0,h_1,\ldots$). \

КИХ (конечная импульсная характеристика \ FIR) – конечное число ненулевых $h_j$.\ 
\[y_j=\sum^{r_2}_{i=-r_1}h_ix_{j-k}\]
Частный случай линейного фильтра – скользящее среднее. \

Будем использовать встроенную функцию filter, которая при параметре method=”convolution” фильтрует с помощью скользящего среднего.\
```{r}
#Moving Average
filter_MA<-function(x,w)
{
  res<-filter(x,c(1/(2*w), rep(1/w, w-1), 1/(2*w)),method="convolution",sides=2)
  plot(x,type="l")
  lines(res,col="red")
}
filter_MAR<-function(x,w)
{
  res<-filter(x,c(1/(2*w), rep(1/w, w-1), 1/(2*w)),method="convolution",sides=2)
  return(res)
}

```
 
Воспользуемся фильтром с периодом 12 чтобы убрать сезонность. 
Посмотрим его АЧХ. Помним, что если период четный, у нас 12, тогда лучше взять длину окна 13 таким образом, чтобы крайние были по половинке частоты.
```{r}
afc <- function(filter, omega) {
  k <- seq_along(filter) - 1
  h <- function(o) sum(rev(filter) * exp(-k*1i * o)) 
  abs(sapply(omega, h))
}


freq <- seq(0, pi, 0.001)
filt <- c(1/24, rep(1/12, 11), 1/24)
omega <- freq/2/pi
plot(afc(filt, freq) ~ omega, type = "l",xaxt="n",main="АЧХ: фильтрация с периодом 12")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```

По АЧХ видно что обнуляется частоты с перодом 12,6 и тд и как уменьшает высокие частоты. \
Посмотрим на периодограмму данного фильтра.
```{r}
filter_12<-filter(series_ts,filt,method="convolution",sides=2)
#,ylim=c(0,1)
spec.pgram(filter_12,ylim=c(0,1),log="no",detrend=FALSE,xaxt='n',fast =FALSE,main="Ряд без сезонности",ann="False", na.action = na.omit)
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))
```

По периодограмме видно, что сезонности нет. Пиков, кроме низких частот, нет, значит фильтр сработал хорошо. 
Давайте посомтрим как выглядит сам график теперь.
```{r}
plot.ts(cbind(series_ts,filter_12), plot.type = "single",col=c("black","red"))
```




##Выбор длины окна в скользящем среднем

Период нашего аременного ряда - 12 месяцев и окна мы выбираем так, чтобы 12 было кратным.\
Вопрос: как подобрать длину окна (количество точек, которые мы используем для приближения одного элемента).\

Если окно маленькое, то будет сглаживание мелких колебаний. Если выберем большую ширину окна, тем сильнее будет сглаживание – среднее значение изменение ряда (тренд).Рассмотрим АЧХ фильтров и результаты фильтрации.



```{r}
filt <- c(1/24, rep(1/12, 11), 1/24)
plot(afc(filt, freq) ~ omega, type = "l",xaxt="n",main="АЧХ: фильтрация с периодом 6")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
filter_MA(series_ts,12)
```
Заметим, что с точки зрения выделения тренда, с 12-ю получается не оцень гладкий тренд. Поэтому попробуем взять, например, 24 (25 c половинками на краях).

```{r}
filt <- c(1/48, rep(1/24, 23), 1/48)
plot(afc(filt, freq) ~ omega, type = "l",xaxt="n",main="АЧХ: фильтрация с периодом 6")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
filter_MA(series_ts,24)
```


Также видим, что часть точек в начале и в конце графика не отображает фильтрация.Это происходит из-за того что по краям нам не хватает достаточное количество точек для определения точки.\


##Сглаживание временного ряда и выделение тренда 

Здесь можно ощутить разницу между сглаживанием и выделением тренда. Сглаживание - сгладить ряд, то есть снять случайные колебания. За счет того, что в сглаживаниив том или ином виде участвует усреднение, то противоположные колебания обращаются в ноль. Если мы выберем маленькую ширину окна, то будем наблюдать именно этот результат - сглаживание мелких колебаний. \
Если выберем большую ширину окна, то сглаживание будет сильным, в итоге получится в чистом виде среднее значение изменения ряда - это и есть тренд.\

Вопрос: что делать с отсутствием части ряда в начале и в конце графика - "хвостов" при сглаживании? (Сглаживании, как я поняла, также подразумевает наличие хвостов.)\
Для этого вместо "хвостов" можно например взять реальные данные или использовать на "Хвостах" фильтр с меньшей длиной окна. Попробуем второй вариант. Для этого в функции filter установим circular=TRUE.
```{r}
filt <- c(1/24, rep(1/12, 11), 1/24)
filter_12<-filter(series_ts,filt,method="convolution",sides=2,circular=TRUE)
plot.ts(cbind(series_ts,filter_12), plot.type = "single",col=c("black","red"))
```

Сделаем окно побольше чтобы явно убедится, что хвосты "заполнены".Нарисуем красной линеей с хвостами, а зеленой без хвостов. 
```{r}
filt <- c(1/72, rep(1/36, 35), 1/72)
filter_12_1<-filter(series_ts,filt,method="convolution",sides=2,circular = TRUE)
filter_12_2<-filter(series_ts,filt,method="convolution",sides=2)
plot.ts(cbind(series_ts,filter_12_1,filter_12_2), plot.type = "single",col=c("black","red","green"))
```

##Проверка
Надо бы проверить, можно ли использовать circular для таких целей. Можно взять ряд, у которого значения слева сильно отличаются от значений с правой стороны и посмотреть на осмысленность результата (вдруг эта опция соответствует тому, что когда заканчиваются значения справа, они дополняются значениями слева, как бы по кругу).


```{r}

#data("AustralianWine")
#wine <- window(AustralianWine, end = time(AustralianWine)[120])
#fort <- ts(wine[, "Red"],frequency = 12) 
filt <- c(1/24, rep(1/12, 11), 1/24)

#filter_fort_1<-filter(fort,filt,method="convolution",sides=2,circular=TRUE)
#filter_fort_2<-filter(fort,filt,method="convolution",sides=2)
#plot.ts(cbind(fort,filter_fort_1,filter_fort_2), plot.type = "single",col=c("black","red","green"))

```

Видим, что это была плохая идея.
Для данного случая можно воспользоваться следующим кодом:
```{r}
MoveA_plot <- function(x, n) {
  new_x <- x
  s<- rep(0, length(x))
  count <- rep(0, length(x))+ !is.na(new_x)
  new_x[is.na(new_x)] <- 0
  s <- s + new_x
      for (i in 1:(n/2)){
            new_x   <- c(rep(NA, i), x[1:(length(x)-i)])
            count <- count + !is.na(new_x)
            new_x[is.na(new_x)] <- 0
            s <- s + new_x
      }
      for (i in 1: (n/2)) {
            new_x   <- c(x[(i+1):length(x)], rep(NA, i))
            count <- count + !is.na(new_x)
            new_x[is.na(new_x)] <- 0
            s <- s + new_x
      }
  plot(x)
  lines(s/count,col="red")
}
#MoveA_plot(fort,12)
```



##Периодограмма остатка после выделения тренда.
```{r}
#remainder
filter_MA_R<-function(x,w)
{
  res<-stats::filter(x,c(1/(2*w),rep(1/w,w-1),1/(2*w)),method="convolution",sides=2)
  return(na.omit(x-res))
}

ost_12<-filter_MA_R(series_ts,12)

spec.pgram(ost_12,log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Педиограмма остатка фильтра с периодом 12",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))
```

Понятие тренда относительное, но если есть периодичность, то тренд должен меняться медленнее чем период. Другими словами тренд должен лежать левее 1/12. То есть в остатке тренда нет.\
Но видим небольшой скачок на 6/12, 2/12 - есть cos с периодом 2, 6 и 12.

Помним, что если автокорреляция остатка напоминает белый шум, значит сигнал выделили хорошо.
```{r}
acf(ost_12)
```
Видим, что периодичность осатлась, но так как мы хотели выделить тренд, то все хорошо.





#Амплитудно-частотная характеристика фильтра (АЧХ).

\[H_{\phi}(z)=\sum_{i}h_iz^{-i} \text{-передаточная функция},\text{ возьмем } z=\exp{(i2\pi w)},  A_{\phi}(w)=|H_{\phi}(e^{i2\pi w})| \text{ - амплитудно-частотная характеристика (АЧХ)} \]
Рассмотрим АЧХ фильтра, воспользуемся написанной Н. Э. Голяндиной функцию.
 
```{r}
afc <- function(filter, omega) {
k <- seq_along(filter) - 1
h <- function(o) sum(rev(filter) * exp(-k*1i * o)) 
abs(sapply(omega, h))
}
```




##Разность соседних точек

```{r}
diff<-function(row){
  n<-length(row)
  new_row<-rep(NA,n-1)
  for (i in 2:n){
    new_row[i-1]<-row[i]-row[i-1]
  }
    return(new_row)
}

spec.pgram(series_ts,log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Педиограмма временного ряда",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))

freq <- seq(0, pi, 0.001)
filt_diff <- c(1/2,-1/2)
omega <- freq/2/pi
plot(afc(filt_diff, freq) ~ omega, type = "l",xaxt="n",main="АЧХ: Разность соседних точек")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), 
     labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```

По АЧХ видно, что данный фильтр подавляет низкие частоты и увеличивает высокие, другими словами выделяет шум. 


```{r}
spec.pgram(diff(series_ts),log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Педиограмма ряда с фильтром: Разность соседних точек",ann="False")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), 
     labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)

```

По периодограмме видно, что данный фильтр действительно подавляет высокие частоты и увеличивает низкие.

##Cумма соседних точек

```{r}
sum<-function(row){
  n<-length(row)
  new_row<-rep(NA,n-1)
  for (i in 2:n){
    new_row[i-1]<-row[i]+row[i-1]
  }
    return(new_row)
}


spec.pgram(series_ts,log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Педиограмма временного ряда",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))

freq <- seq(0, pi, 0.001)
filt_sum <- c(1/2,1/2)

omega <- freq/2/pi
plot(afc(filt_sum, freq) ~ omega, type = "l",xaxt="n",main="АЧХ: Cумма соседних точек")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), 
     labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```

По АЧХ видно, что данный фильтр увеличивает низкие частоты и уменьшает высокие, другими словами выделяет тренд.
```{r}
spec.pgram(sum(series_ts),log="no",detrend=TRUE,xaxt='n',fast =TRUE,main="Педиограмма ряда с фильтром: Cумма соседних точек",ann="False")
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)

```

Видим, что высокие частоты взмылись аж до 600, что и требовалось.





#Выделение тренда с помощью параметрической регрессии

##Линейная регрессия

Убедимся, что линейная регрессия нам не подходит для выделения нелинейного тренда.
```{r}
series[,1]<-as.double(series[,1])
regres<-function(i){
reg<-  lm(series[,2] ~ poly(series[,1],i),data=series)
plot(series,type="l")
lines(reg$fitted.values, col='red')
}
regres(1)
```

##Полиномиальная регрессия
(не подходит для прогнозирования)\
Квадратичная тоже плохо приближает.
```{r}
regres(2)
```

Давайте сразу замахнемся на высокую степень полинома, например 12. 
```{r}
regres(12)
```

Уже более похоже на тренд.

#Растекание частоты в периодограмме.
Пример \[x_n=A\cos(2\pi w n+\phi),n=1:N\]
$w=\frac{k}{N}$ - означает попадание в решетку\
$w \not=\frac{k}{N}$ - не попадает в решетку, $\cos$ не ортогонален ни одному вектору из базиса - РАСТЕКАНИЕ ЧАСТОТЫ (когда частоты не попадают в решетку)\
Приведем периодограмму наглядного примера растекания частоты. 
```{r}

spec.pgram(cos(2*pi*1:54*2/11),  log='no',detrend = FALSE, fast = FALSE,taper=0, pad=TRUE,main="Педиограмма растекания частоты",ann="False",xaxt='n') 

axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), 
     labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)


```


##Подправка длины ряда для ее устранения.
Два варианта:\
1. ряд урезается\
2. дополняется нулями\

Воспользуемся вторым вариантом и добавим один ноль, чтобы количество делилось на 11.
```{r}
x<-c(1:54,0)
spec.pgram(cos(2*pi*x*2/11),  log='no',detrend = FALSE, fast = FALSE, main="Педиограмма с подправкой длины ряда",ann="False",xaxt='n', taper=0,pad=TRUE) 
axis(1, at = c( 0,1/12, 2/12, 3/12, 4/12, 5/12,1/2), 
     labels = c("0","1/12", "2/12", "3/12", "4/12", "5/12","1/2"), las = 2)
```


Видим, что растекания нет.

# Аддитивная и мультипликативная модели данных 

###Аддитивная модель
\[X_n=T_n+C_n+E_n\]
где $T_n$ - тренд, $C_n$ - постоянная амплитуда, $E_n$ - постоянная дисперсия шума. 

###мультипликативная модель
\[X_n=T_n(1+C_n)(1+E_n)=T_n+T_nC_n+T_n(1+C_n)E_n\]
$T_n$- тренд, $T_nC_n$-амплитуда колебаний ведет себя пропорционально тренду, $T_n(1+C_n)E_n$ - Шум пропорционален всему сигналу(шуму с колебанием).

###Преобразования для стабилизации дисперсии
1.мультипликативная модель - $\ln(X)$\
2.пуассоновский шум - $\sqrt{X}$\
3.данные имеют вид от 0 до 1 (типо вероятности) и зависимость $\sigma(X)=\sqrt{X(1-X)}$ - $\arcsin{X}$

Давайте рассмотрим наш ряд
```{r}
plot.ts(series_ts)
```
Предполагаю, что модель аддитивная, так как размер амплитуды/шума постоянны по всему ряду(не ведет себя пропорционально тренду + шум не пропорционален всему сигналу).

#Скользящая медиана
(Сравним скоььзящее среднее и скользящую медиану)
Среднее арифметическое очень зависит от аутлайнеров. Скользящая медиана решает проблему выбросов, так как является устойчивой, робастой оценкой, но при этом график скользящей медианы не будет гладкой кривой. Также она не является оценкой математического ожидания, если распределение несимметричное.

```{r}
med <- runmed(series_ts, 12)
filt <- c(1/24, rep(1/12, 11), 1/24)
MA<-filter(series_ts,filt,method="convolution",sides=2)
plot.ts(cbind(series_ts,med,MA), plot.type = "single",col=c("black","blue","orange"))
legend("topright", legend = c("Среднее", "Медиана"), col = c("orange","blue"), lty = 1)
```

Види, что некоторые скачки шума медиана воспринимает как аутлайнеры.\


Давайте добавим аутлайнеры.
```{r}
series_ts_out<-series_ts
series_ts_out[10]<-120
series_ts_out[100]<-200
series_ts_out[170]<- -100
med <- runmed(series_ts_out, 12)
filt <- c(1/24, rep(1/12, 11), 1/24)
MA<-filter(series_ts_out,filt,method="convolution",sides=2)
plot.ts(cbind(series_ts_out,med,MA), plot.type = "single",col=c("black","blue","orange"))
legend("topright", legend = c("Среднее", "Медиана"), col = c("orange","blue"), lty = 1)
```

Видим, что среднее реагируюет на аутлайнеры, а медиана нет.\

Также есть идея использовать сначала скользящую медиану для убирания аутлайнеров, а потом среднее для гладкости функции.
```{r}
med <- runmed(series_ts, 12)
filt <- c(1/24, rep(1/12, 11), 1/24)
MA<-filter(med,filt,method="convolution",sides=2)
plot(series,type="l")
lines(med,col="red")
lines(MA,col="blue")
legend("topright", legend = c("Медиана+Среднее", "Медиана"), col = c("blue","red"), lty = 1)


```




#Выделение тренда с помощью метода LOESS (local regression)
LOESS - сглаживание с помощью построения локальных линейных регрессий.\
LONESS (local weighted regression)- сглаживание с помощью построения локальных взвешенных линейных регрессий.\
Другими словами глобальный метод локализуем к кусочкам ряда. Данное сглаживание не обязательно только для ВР, просто для них многие вещи упрощаются.\
Например мы можем задать процент ближайших точек к заданной точке x. Для ВР этот процент равностоящих точек и их не надо высчитывать.\
Мы можем задать для каждой точке $h$ - половину окна и построить по полученным точка линейную регрессию.Степень гладкости построенных точек зависит от h.\
$d$ - порядок полинома. Стандартно d=1 - локальная линейная (биномиальная) регрессия. d=0 - среднее значение (const).\
Обе функции используют веса трикубические:
(Но в lowess можно еще делать внешние циклы по устранению выбросов с помощью уменьшения их весов.
Рассмотрим взвешенную линейную регрессию с трикубическими весами:)
\[w(y)=(1-|\frac{d}{n}|^3)^3, \text{ где } d = dist(y,x).\]

Регрессия Лесса может быть применена с loess()использованием числового вектора, чтобы сгладить его и предсказать Y локально (т. Е. В пределах обученных значений X s ). Размер окрестности можно контролировать с помощью spanаргумента, который находится в диапазоне от 0 до 1. Он контролирует степень сглаживания. Таким образом, чем больше значение span, тем более плавной является подгоночная кривая.\
Переменной предиктора могут быть просто индексы от 1 до количества наблюдений при отсутствии поясняющих переменных. 
(Ширина окна сглаживания span = 0.2, степень полинома degree = 2)
```{r}

mod_loess <- loess(series$level~ series$DATE, data = series,span = 0.2,degree = 2)      
trend.loess <- predict(mod_loess)

plot(series$level, type="l", main="Loess Smoothing and Prediction", xlab="Date", ylab="Unemployment (Median)")
lines(trend.loess, col="red")
```

#Hodrick-Prescott filter
\[h_i=argmin_{s_i} \sum_{i=1}^{N}(x_i - s_i)^2 +\lambda \sum_{i=1}^{N-1} [(s_{i+1}-s_i)-(s_i-s_{i-1})]\]
Вторым слагаемым ищем где вторая производная небольшая. \
Также замечаем, чем меньше $\lambda$, тем кривее тренд. Чем больше $\lambda$, тем более гладкий тренд.
```{r}
library(mFilter)


mod_hp <- hpfilter(series$level,freq=129600,type="lambda")
plot(series$level,type="l")
lines(mod_hp$trend,col="red")
```

Видим, что тренд более гладкий, давайте возьмем другое значение $\lambda$.
```{r}
mod_hp <- hpfilter(series$level,freq=1200,type="lambda")
plot(series$level,type="l")
lines(mod_hp$trend,col="red")
```



