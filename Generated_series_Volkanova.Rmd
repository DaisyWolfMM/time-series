---
title: "generated_series"
author: "Волканова Маргарита"
date: '5 мая 2019 г '
output:
  html_document:
    toc: true 
    toc_depth: 3
    toc_float: true
    number_sections: true
---

#Реальный ряд
Данные: Ежемесячные продажи белого в тысячах литров с января 1980 года по июль 1995 года. Виноделами в бутылках объемом не более 1 литра. Многомерный временной ряд с 187 наблюдениями 

```{r}
library(stats)
library(Rssa)
data("AustralianWine")
wine <- window(AustralianWine, end = time(AustralianWine)[180])
fort <- ts(wine[, "Drywhite"],frequency = 12)
plot(fort)
```

Тренд возрастает,отдаленно напоминает линейный, но явно есть отклонения от него. Предполагаю, что модель мультипликативная, так как амплитуда колебаний ведет себя пропорционально тренду и шум пропорционален всему сигналу.

#Разложение SSA

```{r}
spec.pgram(fort,log="no",detrend=TRUE,xaxt='n',fast =FALSE,main="Общая периодограмма",ann="False")
axis(1, at = c(0,1,2,3,4,5,6), labels = c('0', '1/12', '2/12', '3/12', '4/12', '5/12', '6/12'))
```

Из периодограммы видно, что есть сезонные компоненты с частотами 1/12, 2/12, 3/12, 4/12, 5/12,6/12. 


Для разложения SSA надо использовать длину окна кратно периоду и максимально близкую к половине длины ряда.Взяла длину равную 60, чтобы компоненты сезонности смешивались меньше, теперь длина окна делится на все периоды. 
```{r}
ssa_fort <- ssa(fort, L = 60)
#График собственных чисел
plot(ssa_fort)
#График одной компоненты 
plot(ssa_fort, type = "vectors", idx = 1:20)
#Рассмотрим парные графики 
plot(ssa_fort,  type = "paired", idx = 1:20)
#Корреляционная матрица.
plot(wcor(ssa_fort, groups = 1:20))
```

К тренду отнесем 1,14 компоненты, как медленно меняющиеся.
Четко просматриваются такие гармоники, как 2:3, 4:5, 10:11. Судя по корреляционной матрице 6:9 очень плохо разделимы.  

Сначала посмотрим как выделится тренд. 

```{r}
fort_t_s<- reconstruct(ssa_fort , groups = list(trend = c(1,14),season = c(2:3,4:5,6:7,8:9,10:11,12:13)))
plot(fort,type='l')
lines(fort_t_s$trend,col="blue")
```

Мне нравится как выглядит.

Посмотрим периоды
```{r}
pe <- parestimate(ssa_fort, groups = list(1:14), method = "esprit")
pe
```

Одна пара с периодом 72 не относятся к сезонности. А так есть все что нужно, 2.4, 12,6,4,3,2.

Давайте посмотрим на периодическую составляющую ряда. 
```{r}
plot(fort_t_s$season)
```

Автоматическая идентификация работает в условиях разделимости компонент, поэтому рассмотрим iossa и fossa сразу же. 

#Улучшение разложения - iossa и fossa
Хотим чтобы элементы были разделимы с учетом попарных гармоник 2:13. 

##Iossa
Попробуем улучшить слабую разделимость.
```{r}
#PS Хотела еще выделить 12:13, 14 - но мне там корреляционная матрица не понравилась 
iossa_fort  <- iossa(ssa_fort , nested.groups = list(6:7,8:9,12:13,14), maxiter = 1000)
plot(wcor(ssa_fort, groups = 1:20), main = "SSa")
plot(wcor(iossa_fort, groups = 1:20) , main = "iossa")
```

Видим, что красиво разделил гармоники 6:7, 8:9 и 13(пила), к тренду отнесем 1,12,14. 
```{r}
#График одной компоненты 
plot(iossa_fort, type = "vectors", idx = 1:20)
#Рассмотрим парные графики 
plot(iossa_fort,  type = "paired", idx = 1:20)

```

Сейчас очень классно видно 6:7 на парных графиках. У 8:9 видимо период 2.4.
Если сравнить с исходными парными графиками, то на прошлых прям видно как они перемешались, особенно когда видишь, как разделил iossa. 

Еще к тренду добавилась компонента 12. Давайте сравним с SSA.

```{r}
io_re_fort <- reconstruct(iossa_fort, groups = list(trend = c(1,12,14),season = c(2:3,4:5,6:7,8:9,10:11,13)))
io_res_fort<- residuals(io_re_fort)
plot(fort,type='l')
lines(fort_t_s$trend,col="blue")
lines(io_re_fort$trend,col="red")
legend("topleft", legend = c( "ssa","iossa"), col = c("blue","red"), lty = 1)
```

Тренд более выпуклый в нужных местах. Считаю, что выделился лучше, чем при разложении SSA. 
```{r}
plot(fort_t_s$season)
lines(io_re_fort$season,col="red")
```

Сезонность особо не поменялась.

Смотрим остатки и сразу на автокорреляцию: 
```{r} 
acf(io_res_fort)
Box.test(io_res_fort,  type = "Ljung-Box")
``` 

Гипотеза, что шум является белым, не отвергается.   


##Fossa
Попробуем улучшить сильную разделимость.
```{r}
fo_re_fort  <- fossa(ssa_fort , nested.groups = list(6:7,8:9,12:13,14), maxiter = 1000)
fo_res_fort<- residuals(fo_re_fort)
plot(wcor(ssa_fort, groups = 1:20), main = "SSa")
plot(wcor(iossa_fort , groups = 1:20), main = "iossa")
plot(wcor(fo_re_fort , groups = 1:20), main = "fossa")

```

Видим, что у fossa чуть хуже и по-другому расположены парные и одинарные компоненты.

```{r}
#График одной компоненты 
plot(fo_re_fort, type = "vectors", idx = 1:20)
#Рассмотрим парные графики 
plot(fo_re_fort,  type = "paired", idx = 1:20)

```

Теперь по графику одной компоненты к тренду отнесем компоненты 1,13,14 как медленно меняющиеся. 
К сезонности отнесем по корреляционной матрице и по парным графикам 2:3,4:5,6,7:8,10:11.

```{r,echo=FALSE}
fo_re_fort <- reconstruct(fo_re_fort, groups = list(trend = c(1,13:14),season = c(2:3,4:5,6,7:8,10:11)))
#io_res_fort<- residuals(io_re_fort)
plot(fort,type='l')
lines(fort_t_s$trend,col="blue")

lines(io_re_fort$trend,col="red")
lines(fo_re_fort$trend,col="green")
legend("topleft", legend = c( "ssa","iossa","fossa"), col = c("blue","red","green"), lty = 1)
```

Тренд почти не отличается от iossa.

```{r}
plot(fort_t_s$season)
lines(io_re_fort$season,col="green")
lines(fo_re_fort$season,col="red")
```

А вот сезонность явно лучше. 


```{r} 
acf(fo_res_fort)
Box.test(fo_res_fort,  type = "Ljung-Box")
``` 
И по тесту и по автокорреляции (в начале дуга) видно, что остатки не белый шум. 

#Автоматическая идентификация
(Или автоматическая группировка) Можно делать по матрице взвешенных корреляций, а также идентификацию тренда по периодограмме. 

##Частотная группировка

Рассмотрим группировку элементарных рядов с использованием периодограммы,группирует элементарные компоненты автоматически, используя их частотные вклады.

Параметры: 

base = c(“series”, “eigen”, “factor”) – элементарные компоненты, собственные вектора или факторные вектора (то что подаем на вход периодограммы) 

freq.bins – диапозон частот

threshold - порог вклада,«Порог» - это вектор, соответствующее значение порога будет использоваться для каждого интервала


Выделим тренд. 
```{r}

library(Rssa)
ssa_fort <- ssa(fort, L = 60)
auto_component<-grouping.auto(ssa_fort,grouping.method="pgram",base = "series",threshold=0.80,freq.bins=c(1/24))
#threshold подобрала
auto_component$F1

```

Изобразим получившийся тренд 
```{r}
auto_fort<- reconstruct(ssa_fort, list(groups = auto_component$F1))
auto_trend<-auto_fort$groups


plot(fort,type='l')

lines(fo_re_fort$trend,col="blue")
lines(io_re_fort$trend,col="green")
lines(fort_t_s$trend,col="orange")
lines(auto_trend,col='red')
legend("topleft", legend = c("fossa", "iossa","SSA","auto"), col =c("blue","green","orange","red"), lty = 1)
```

К прошлому графику тренда можно добавить, что ssa совпадает с auto. 

Посмотрим на ряд без тренда. 
```{r}
auto_res<-fort-auto_trend
plot(auto_res)
```


##Кластерная группировка

Теперь надо выделить периодическую составляющую ряда. Для этого воспользуемся группировкой на основе матрицы взвешенных корреляций.
```{r}
#iossa_fort  <- iossa(ssa_fort , nested.groups = list(6:7,8:9,12:13,14), maxiter = 1000)
ser_res<-ssa(auto_res, L = 60)
plot(wcor(ser_res, groups = 1:20))
```

Как-то совсем все грустно с разделимостью, давайте воспользуемся iossa. 
```{r}
ser_res  <- iossa(ser_res , nested.groups = list(1:2,3:4,5:6,7:8,9:10,11), maxiter = 1000)
#ser_res<-ssa(auto_res, L = 60)
plot(wcor(ser_res, groups = 1:20))
```


Хочу 6 кластеров для 5 компонент сезонности + остаток. 
```{r}
#nclust целое число, желаемое количество выходных рядов
auto_component<-grouping.auto(ser_res,grouping.method="wcor",nclust=6)
auto_component[1:6]

```
Посмотрим парные графики.

```{r}
plot(ser_res,  type = "paired", idx = 1:20)
```

Мне нравится как получилось. 
Посмотрим как получилась сезонность. 
```{r}
season_rec <- reconstruct(ser_res, groups = auto_component)
auto_season<-season_rec$`1`+season_rec$`2`+season_rec$`3`+season_rec$`4`+season_rec$`5`
plot(auto_season)
```



#Сгенерированный ряд
Смоделируем ряд с двумя гармониками, экспоненциальным трендом и белым шумом.  
\[y_n=8\exp(0.01*n)+5\cos(2\pi n/7)+3\cos(2\pi n/3)+\epsilon_n\]
Общий вид ряда в вещественной форме:
\[x_n=\sum_{k=1}^{m}P_{m_k}(n)\rho^n_k\cos(2 \pi w_kn+\phi_k) \]
 Общий вид ранга конечного ряда, когда разрешаем $\mu_k$ - комплексного вида.
 \[x_n=\sum_{k=1}^p P_{m_k}(n)\mu_k^n, \text{ , где } \mu_k=\rho_k\exp(+-i2\pi w_k), \text{  } 0<w_k<1/2\]
 \[\mu_k=\rho_k,  w_k=0\]
 \[\mu_k=-\rho_k,  w_k=1/2\]
Пусть k=1, тогда $m_1=0$ (полинома нет) $P_{m_1(n)}=C_1,\rho_1=\exp(0.01), w_1=0, \phi_1=0$\

Пусть k=2, тогда $m_2=0$ , $P_{m_2(n)}=C_2,\rho_2=\exp(0)=1, w_2=+-1/3, \phi_2=0$ - косинус с периодом 3\

Пусть k=3, тогда $m_3=0$ , $P_{m_3(n)}=C_3,\rho_3=\exp(0)=1, w_3=+-1/7, \phi_3=0$ - косинус с периодом 7\

Ранг данного ряда равен 1+2+2=5.\


Сначала проверим корни не добавляя шум.
```{r}
n<-seq(1,100)
#Без шума
ser<-3*cos(2*pi*n*(1/3))+5*cos(2*pi*n*(1/7))+8*exp(0.01*n)
#c шумом
ser_e<-3*cos(2*pi*n*(1/3))+5*cos(2*pi*n*(1/7))+8*exp(0.01*n)+rnorm(n,sd=0.3)
ts.plot(ser)
lines(ser_e,col="red")
legend("topleft", legend = c("с шумом", "без шума"), col =c("black","red"), lty = 1)
```



$\rho=exp(0.01)=1.01005...$( - поведение амплитуд, ведет себя как $\rho^n$\)

$\cos(2\pi/7)+-i\sin(2\pi/7)=0.6234...+-i0.7818...$
$\cos(2\pi/3)+-i\sin(2\pi/3)=-0.5+-i 0.866...$

Попробуем получить рекуррентное соотношение для нашего ряда.
Так как ранг ряда равен 5, то берем окно равную 6. Воспользуемся функцией LRR и посмотри корни. 
```{r}
Lrr_ser<-lrr(ssa(ser,L=6),groups=list(1:5))
Lrr_ser_e<-lrr(ssa(ser_e,L=6),groups=list(1:5))
roots(Lrr_ser)
roots(Lrr_ser_e)
```
Видим, что корни ряда без шума точно совпадают с истинными, а ряд с шумом имеет погрешность.  

$\rho= \exp^{i 2\pi\omega}$ 
Сравним модули.
```{r}
Mod(roots(Lrr_ser))
Mod(roots(Lrr_ser_e))

```

Сравним периоды (должны быть 7 и 3).
```{r}
2*pi/Arg(roots(Lrr_ser))[1:5]
2*pi/Arg(roots(Lrr_ser_e))[1:5]
```



```{r}
plot(Lrr_ser)

plot(Lrr_ser_e,col="red")
```

##Построение явной формулы для сигнала 

###Модельный ряд без шума
```{r}
SSAbrth <- ssa(ser, L = 50)
SSAbrth_e <- ssa(ser_e, L = 50)
plot(SSAbrth)
plot(SSAbrth, type = "vectors", idx = 1:10)
plot(SSAbrth, type = "paired", idx = 1:10)
```

Рассмотрим сигнальные корни на окружности $\mu_m$.
```{r}
root_<-parestimate(SSAbrth, groups = list(c(1:5)), method = "esprit")
root_s<-root_$roots
#parestimate(SSAbrth_e, groups = list(c(1:5)), method = "esprit")
plot(root_)
```

Пусть $x_n=\sum_{m=1}^{d}C_m\mu_m^n$

\[x_1=\sum_{m=1}^{d}C_m\mu_m \\ x_2=\sum_{m=1}^{d}C_m\mu_m^2 \\ \ldots \\ x_d=\sum_{m=1}^{d}C_m\mu_m^d\]

Или если записать в матричном виде:
\[
X=\begin{pmatrix}
  \mu_1 &\ldots & \mu_d\\
  \mu_1^2 & \ldots & \mu_d^2\\
   \ldots &  \ldots &  \ldots \\
   \mu_1^d & \ldots & \mu_d^d
\end{pmatrix}C = WC\]

Находим коэффициенты:
$C=W^{-1}X$

```{r}
X<-ser[1:5]
Matrix_W<-function(n){mapply(function(root){root^(1:n)}, root_s)}
W <- Matrix_W(5)
c<-Re(solve(W)%*%X)
c
```
Строим явную формулу для каждого значения ряда
```{r}
LRF <- function(n){
return(Re(mapply(function(root){root^(n)}, root_s)%*%c) ) }

plot(ser, type = 'l', ylab = "series")
lines( LRF(1:100), type = 'l',col = 'red')
```

Видим, что графики совпали. 


###Модельный ряд с шумом

```{r}
plot(SSAbrth_e, type = "vectors", idx = 1:10)
plot(SSAbrth_e, type = "paired", idx = 1:10)
```



```{r}
root_e<-parestimate(SSAbrth_e, groups = list(c(1:5)), method = "esprit")
root_se<-root_e$roots
plot(root_e)



```


Находим коэффициенты:
$C=W^{-1}X$

```{r}

signal <- reconstruct(SSAbrth_e , groups = list(c(1:5)))
Matrix_W<-function(n){mapply(function(root){root^(1:n)},root_se)}
W <- Matrix_W(length(signal$F1 ))
c <- solve(t(W) %*% W) %*% t(W)%*%signal$F1
c
```



Строим явную формулу для каждого значения ряда
```{r}
LRF <- function(n){
return(Re(mapply(function(root){root^(n)}, root_s)%*%c) ) }

plot(ser, type = 'l', ylab = "series")
lines( LRF(1:100), type = 'l',col = 'red')
```

Видим, что графики немного различаются из-за шума. 


 
###Реальный ряд

```{r}
signal <- reconstruct(ssa_fort, groups = list(c(1:14)))
plot(ssa_fort, type = "vectors", idx = 1:20)
plot(ssa_fort,  type = "paired", idx = 1:20)

```

Ранг сигнала беру 14(количество компонент, которые мы относим к сигналу). Смотрим сигнальные корни на окружности. 
```{r}
root_fort<-parestimate(ssa_fort, groups = list(c(1:14)), method = "esprit")
plot(root_fort)
root_fort$roots
```

Находим коэффициенты.
```{r}
Matrix_W<-function(n){mapply(function(root){root^(1:n)},root_fort$roots)}
W <- Matrix_W(length(signal$F1))
c <- solve(t(W) %*% W) %*% t(W)%*%signal$F1
c
```
```{r}
LRF <- function(n){
return(Re(mapply(function(root){root^(n)}, root_fort$roots)%*%c) ) }
plot(ts(fort))
lines( LRF(1:180), type = 'l',col = 'red')
```


